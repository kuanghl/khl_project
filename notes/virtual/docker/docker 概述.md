# docker 概述

* [docker 概述](#docker-%E6%A6%82%E8%BF%B0)
* [docker 平台](#docker-%E5%B9%B3%E5%8F%B0)
* [docker 引擎](#docker-%E5%BC%95%E6%93%8E)
* [使用 docker 可以干什么？](#%E4%BD%BF%E7%94%A8-docker-%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88)
  * [快速一致性的交付应用](#%E5%BF%AB%E9%80%9F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BA%A4%E4%BB%98%E5%BA%94%E7%94%A8)
  * [响应式部署和伸缩](#%E5%93%8D%E5%BA%94%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BC%B8%E7%BC%A9)
  * [在同一个机器上运行更多的工作负载](#%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD)
* [docker 架构](#docker-%E6%9E%B6%E6%9E%84)
  * [docker 主机（守护进程）](#docker-%E4%B8%BB%E6%9C%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B)
  * [docker 客户端](#docker-%E5%AE%A2%E6%88%B7%E7%AB%AF)
  * [docker 注册中心](#docker-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83)
  * [docker 对象](#docker-%E5%AF%B9%E8%B1%A1)
    * [镜像](#%E9%95%9C%E5%83%8F)
    * [容器](#%E5%AE%B9%E5%99%A8)
    * [服务](#%E6%9C%8D%E5%8A%A1)
* [底层技术](#%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF)
  * [命名空间](#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)
  * [控制组](#%E6%8E%A7%E5%88%B6%E7%BB%84)
  * [联盟文件系统](#%E8%81%94%E7%9B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
  * [容器格式](#%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F)

`Docker`是开发、传输和运行应用程序的开放平台。`Docker`使您能够将应用程序与基础架构分开，以便您可以**快速交付**软件。借助`Docker`，您可以像管理应用程序一样管理基础架构。通过利用`Docker`的方法**快速进行传输、测试和部署**代码，`docker`可以显著的缩短缩短编写代码在生产环境中运行代码的时间。

# docker 平台

`docker`提供了在称为容器的**松散隔离**环境中打包和运行应用程序的能力。**隔离和安全性**允许您在给定主机上同时运行多个容器。容器是**轻量级**的，因为它们不需要虚拟机管理程序的额外负载，而是直接在主机内核中运行。这意味着可以在给定的硬件组合上运行更多容器，而不是使用虚拟机(如vagrant)。甚至可以在实际上是虚拟机的主机中运行`docker`容器！

- docker--vm对比
  |特性|虚拟机|	容器|
  |--|--|--|
  |隔离级别| 操作系统级| 进程级别|
  |隔离策略| Hypervisor| CGROUPS|
  |系统资源| 5 - 15%| 0 - 5%|
  |启动时间| 分钟级| 秒级|
  |镜像存储| GB| MB|

`docker`提供工具和平台来管理容器的生命周期：

- 使用容器来开发应用程序及其支持组件。
- 该容器成为分配和测试应用程序的单位。
- 准备就绪后，将应用程序部署到生产环境中，作为**容器或编排服务**。无论生产环境是本地数据中心，云提供商还是两者的混合体，这都是一样的。



# docker 引擎

**Docker Engine**是一个包含以下主要组件的客户端 - 服务器应用程序：

- 一种称为守护进程（`dockerd`命令）的长期运行程序 。
- `REST API`指定程序可用于与守护程序进行通信并指示其执行操作的接口。
- 命令行界面（`CLI`）客户端（`docker`命令）。

![docker](https://docs.docker.com/engine/images/engine-components-flow.png)



`CLI`使用`docker` `REST API`通过脚本或直接`CLI`命令来控制`docker`守护进程或与其进行交互。许多其他docker应用程序使用底层的`API`和`CLI`。

守护进程创建并管理`docker`对象，如`images`, `containers`, `networks`, and `volumes`。



# 使用 docker 可以干什么？



## 快速一致性的交付应用

允许开发人员通过使用提供应用程序和服务的本地容器在标准化环境中工作，`Docker`简化了开发生命周期。容器非常适合持续集成和持续交付（`CI / CD`）工作流程。

考虑以下示例场景：

- 开发人员在本地编写代码并使用`Docker`容器与他们的同事分享他们的工作。
- 使用`Docker`将应用程序推入测试环境并执行自动和手动测试。
- 当开发人员发现错误时，可以在开发环境中修复它们，并将它们重新部署到测试环境进行测试和验证。
- 测试完成后，向客户提供修补程序与将更新后的镜像推送到生产环境一样简单。



## 响应式部署和伸缩

`Docker`的基于容器的平台支持高度**可移植**的工作负载。`Docker`容器可以在开发人员的本地笔记本电脑上，数据中心的物理或虚拟机上，云提供程序上或混合环境中运行。

`Docker`的可移植性和**轻量级**特性也使得动态管理工作负载变得非常容易，可以近乎实时地按业务需求扩展或拆分应用程序和服务。

## 在同一个机器上运行更多的工作负载

`Docker`轻量且快速。它为基于虚拟机管理程序的虚拟机提供了一种可行的，具有**成本效益**的替代方案，因此您可以使用更多计算容量来实现业务目标。`Docker`非常适合**高密度**环境和中小型部署，您需要以**更少的资源实现更多功能**。



# docker 架构

`Docker`使用客户端 - 服务器体系结构。`Docker` *客户端*与`Docker` *守护进程通信*，`Docker` *守护进程*负责构建，运行和分发`Docker`容器。`Docker`客户端和守护进程*可以* 在同一个系统上运行，也可以将`Docker`客户端连接到远程`Docker`守护进程。`Docker`客户端和守护进程使用`REST API`通过`UNIX`套接字或网络接口进行通信。

![docker 架构](https://docs.docker.com/engine/images/architecture.svg)



## docker 主机（守护进程）

`Docker`守护进程（`dockerd`）监听`Docker` `API`请求并管理`Docker`对象，如`images`, `containers`, `networks`, & `volumes`。守护进程还可以与其他守护进程通信来管理`Docker`服务。

Docker主机是作为在您的机器上安装Docker的一部分而创建的。一旦你的Docker主机被创建，它就允许你管理镜像和容器。例如，镜像可以下载，容器可以启动，停止和重新启动。



## docker 客户端

`Docker`客户端是`Docker`用户与`Docker`交互的主要方式。当你使用诸如这样的命令时`docker run`，客户端发送这些命令给`dockerd`其执行。该`docker`命令使用`Docker` `API`。`Docker`客户端可以与多个守护进程进行通信。



## docker 注册中心

`Docker` *注册表*存储`Docker`镜像。`Docker Hub`和`Docker Cloud`是任何人都可以使用的公共注册表，并且`Docker`配置在默认`Docker Hub`上查找镜像。你甚至可以运行你自己的私人注册表。如果您使用`Docker`  `Datacenter`（DDC），它包括`Docker Trusted Registry`（DTR）。

当使用`docker pull`或`docker run`命令时，所需的镜像将从配置的注册表中提取。当使用该`docker push`命令时，镜像被推到配置的注册表中。

[Docker商店](http://store.docker.com/)允许您购买和销售Docker镜像或免费发布。例如，您可以购买包含来自软件供应商的应用程序或服务的`Docker`镜像，并使用镜像将应用程序部署到您的测试临时和生产环境中。您可以通过拉取新版本的镜像并重新部署容器来升级应用程序。

![架构图](https://github.com/docker/labs/raw/master/developer-tools/java/chapters/images/docker-architecture.png)

图1. Docker体系结构

客户端与位于同一主机或不同主机上的引擎进行通信。客户端使用该`pull`命令请求引擎从注册表中提取镜像。然后引擎从Docker Store下载镜像，或者配置任何注册表。可以从注册表下载多个镜像并安装在引擎上。客户端使用`run`运行容器。



## docker 对象

当使用`Docker`时，正在创建和使用镜像、容器、网络、卷、插件和其他对象。本节简要介绍其中一些对象。

### 镜像

---

**一个镜像是一个只读用于创建一个`docker`容器的指令模板**。通常情况下，镜像是基于另一个镜像的，还有一些额外的自定义功能。例如，您可以构建基于该`ubuntu` 镜像的镜像，但安装`Apache Web`服务器和应用程序，以及使您的应用程序运行所需的配置详细信息。

您可能会创建自己的镜像，或者您使用其他人创建并在注册表中发布的镜像。镜像在*注册表*中存储、共享和管理，并且是Docker 的**分发组件**。Docker Store是一个公开可用的注册表，可在[http://store.docker.com](http://store.docker.com/)上找到。为了构建您自己的镜像，您可以使用简单的语法创建*Dockerfile*，以定义创建镜像并运行所需的步骤。`Dockerfile`中的每条指令都会在镜像中创建一个图层。当您更改`Dockerfile`并重建镜像时，只重建那些已更改的图层。与其他虚拟化技术相比，这是使镜像轻量、小巧、快速的一部分。

> 我们已经看到，Docker镜像是从中启动Docker容器的只读模板。每个镜像由一系列图层组成。Docker利用联合文件系统将这些图层合并为一个镜像。联盟文件系统允许将分离文件系统的文件和目录（称为分支）透明地重叠，形成一个统一的文件系统。
>
> Docker轻量级的原因之一是由于这些层。当您更改Docker镜像时（例如，将应用程序更新为新版本），会创建一个新层。因此，不是像替换整个镜像或完全重建一样，而是使用虚拟机，只添加或更新该图层。现在，您不需要分发全新的镜像，只需更新即可，从而更快速，更简单地分发Docker镜像。
>
> 每个镜像都从基础镜像开始，例如`ubuntu`基础`Ubuntu`镜像或`fedora`基础`Fedora`镜像。您也可以使用自己的镜像作为新镜像的基础，例如，如果您有基础的`Apache`镜像，则可以将其用作所有Web应用程序镜像的基础。
>
> **默认情况下，Docker从Docker Store获取这些基础镜像。**
>
> 然后使用一组简单的，描述性的步骤（我们称之为指令）从这些基础镜像构建Docker镜像。每条指令都会在镜像中创建一个新图层。说明包括如下操作：
>
> 1. 运行一个命令
> 2. 添加文件或目录
> 3. 创建一个环境变量
> 4. 启动容器时运行一个进程
>
> 这些指令存储在一个名为`Dockerfile`的文件中。当您请求构建镜像，执行指令并返回最终镜像时，Docker会读取此`Dockerfile`

### 容器

---

**容器是镜像的运行实例**。您可以使用`Docker` `API`或`CLI`创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储器连接到它，甚至可以根据其当前状态创建新镜像。

容器由操作系统、用户添加的文件和元数据组成。正如我们所看到的，每个容器都是从镜像构建的。该镜像告诉Docker容器包含什么，容器启动时要运行的过程以及各种其他配置数据。Docker镜像是只读的。当Docker从一个镜像运行容器时，它会在镜像顶部添加一个读写层（使用前面看到的union文件系统），然后您的应用程序可以运行。

默认情况下，容器与其他容器及其主机相对隔离。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。

容器由其镜像定义，以及在创建或启动容器时提供给它的任何配置选项。当一个容器被移除时，没有在存储在永久改变消失。



**示例`docker run`命令**

以下命令运行一个`ubuntu`容器，以交互方式附加到本地命令行会话并运行`/bin/bash`。

```shell
$ docker run -i -t ubuntu /bin/bash
```

当运行此命令时，会发生以下情况（假定正在使用默认的注册表配置）：

1. 如果`ubuntu`本地没有镜像，`Docker`会从配置的注册表中提取它，就像`docker pull ubuntu`手动运行一样。
2. `Docker`创建一个新的容器，就好像`docker container create` 手动运行了一个命令一样。
3. `Docker`将一个读写文件系统分配给容器，作为它的最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。
4. 由于没有指定任何网络选项，因此`Docker`会创建一个网络接口来将容器连接到默认网络。这包括分配一个`IP`地址给容器。默认情况下，容器可以使用主机的网络连接连接到外部网络。
5. Docker启动容器并执行`/bin/bash`。由于容器是交互式运行并且连接到您的终端（由于`-i`和`-t`）标志，因此可以使用键盘提供输入并将输出记录到您的终端。
6. 当您键入`exit`以终止`/bin/bash`命令时，容器停止但不会被删除。您可以重新启动或删除它。



### 服务

---

通过服务，可以跨多个`Docker`守护进程扩展容器，这些守护进程可以作为一个**集群**与多个**管理节点**和**工作节点**一起*工作*。`swarm`中的每个成员都是Docker守护进程，守护进程都使用Docker `API`进行通信。服务允许定义所需的状态，例如在任何给定时间必须可用的服务的副本数量。默认情况下，该服务在所有工作节点之间进行负载平衡。对于消费者来说，Docker服务似乎是一个单一的应用程序。Docker引擎在Docker 1.12及更高版本中支持`swarm`模式。



# 底层技术

Docker使用[Go](https://golang.org/)编写，利用`Linux`内核的几个特性来提供其功能。

## 命名空间

Docker使用一种叫做`namespaces`提供称为*容器*的独立工作空间的技术。当你运行一个容器时，Docker会为该容器创建一组 *命名空间*。

这些命名空间提供了一个隔离层。容器的每个方面都在单独的名称空间中运行，并且其访问权限限于该名称空间。

Docker引擎在Linux上使用如下的命名空间：

- **pid命名空间：** 进程隔离（PID：进程ID）。
- **net命名空间：** 管理网络接口（NET：网络）。
- **ipc命名空间：** 管理访问IPC资源（IPC：进程间通信）。
- **mnt命名空间：** 管理文件系统挂载点（MNT：Mount）。
- **uts命名空间：** 隔离内核和版本标识符。（UTS：Unix分时系统）。



## 控制组

`Linux`上的`Docker Engine`也依赖于另一种称为*控制组* （`cgroups`）的技术。`cgroup`将应用程序限制为一组特定的资源。控制组允许`Docker`引擎将可用硬件资源共享给容器，并可选地强制实施限制和约束。例如，可以限制可用于特定容器的内存/`CPU`。



## 联盟文件系统

联合文件系统或`UnionFS`是通过创建图层进行操作的文件系统，使它们非常轻巧和快速。`Docker`引擎使用`UnionFS`为容器提供构建块。`Docker`引擎可以使用多种`UnionFS`变体，包括`AUFS`，`btrfs`，`vfs`和`DeviceMapper`。



## 容器格式

Docker引擎将名称空间，控制组和`UnionFS`组合成一个名为容器格式的包装器。默认的容器格式是`libcontainer`。将来，Docker可以通过与诸如`BSD Jails`或`Solaris Zones`等技术集成来支持其他容器格式。